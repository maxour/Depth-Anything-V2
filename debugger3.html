<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>360 Auto-Calibrator (Fixed)</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"
    />
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"
    ></script>

    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: sans-serif;
        background: #1a1a1a;
        color: #ddd;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }

      #panorama {
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* ç»˜å›¾å±‚ (Z-Index å¿…é¡»é«˜äºå…¨æ™¯å›¾ï¼Œä½†ä½äºæ§åˆ¶æ¿) */
      #drawing-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        pointer-events: none;
      }

      /* è§’è‰²å±‚ */
      .character-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
      }
      .avatar-container {
        position: absolute;
        transform-origin: bottom center;
        cursor: grab;
        pointer-events: auto;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: flex-end;
        /* è™šçº¿æ¡† */
        border: 1px dashed rgba(255, 255, 255, 0.5);
      }
      .avatar-container:active {
        cursor: grabbing;
        border-color: #0f0;
      }
      .avatar-img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none;
      }

      /* æ§åˆ¶é¢æ¿ */
      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 340px;
        background: rgba(0, 0, 0, 0.9);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        max-height: 95vh;
        overflow-y: auto;
        box-shadow: -5px 5px 15px rgba(0, 0, 0, 0.5);
      }
      .mode-switch {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      .btn {
        flex: 1;
        padding: 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
        transition: 0.2s;
      }
      .btn.active {
        background: #3498db;
        color: white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }
      .btn.inactive {
        background: #444;
        color: #aaa;
      }
      .btn:hover {
        opacity: 0.9;
      }

      .group {
        background: rgba(255, 255, 255, 0.05);
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 10px;
      }
      .slider-row {
        margin-bottom: 10px;
      }
      .slider-header {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #aaa;
        margin-bottom: 4px;
      }
      input[type="range"] {
        width: 100%;
        cursor: pointer;
      }
      input[type="file"] {
        font-size: 11px;
        width: 100%;
        margin-bottom: 5px;
      }

      .status-box {
        background: #222;
        padding: 8px;
        border-radius: 4px;
        margin-top: 5px;
        font-size: 11px;
        color: #0f0;
        font-family: monospace;
        border-left: 3px solid #0f0;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas ref="depthCanvas" style="display: none"></canvas>

      <canvas ref="drawCanvas" id="drawing-layer"></canvas>

      <div id="panorama"></div>

      <div class="character-layer" v-if="charImgSrc">
        <div
          class="avatar-container"
          :style="{ 
                 left: charPos.x + 'px', top: charPos.y + 'px',
                 width: params.baseWidth + 'px',
                 transform: `translate(-50%, -100%) scale(${currentScale})` 
             }"
          @mousedown.stop.prevent="startDrag"
        >
          <img :src="charImgSrc" class="avatar-img" />
        </div>
      </div>

      <div class="controls">
        <h3>ğŸ“ Auto-Calibrator v2</h3>

        <div class="group">
          <div class="slider-row">
            <div class="slider-header">
              <span>Character Base Size (px)</span
              ><span>{{ params.baseWidth }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.baseWidth"
              min="50"
              max="500"
              step="10"
            />
          </div>
        </div>

        <div class="mode-switch">
          <button
            class="btn"
            :class="mode === 'preview' ? 'active' : 'inactive'"
            @click="setMode('preview')"
          >
            ğŸ– æ‹–æ‹½é¢„è§ˆ
          </button>
          <button
            class="btn"
            :class="mode === 'calibrate' ? 'active' : 'inactive'"
            @click="setMode('calibrate')"
          >
            âœï¸ ç»˜åˆ¶ç­‰è·ç‚¹
          </button>
        </div>

        <div v-if="mode === 'calibrate'">
          <div
            style="
              font-size: 11px;
              color: #ddd;
              margin-bottom: 10px;
              line-height: 1.4;
              background: #333;
              padding: 8px;
              border-radius: 4px;
            "
          >
            <strong>æ“ä½œæ­¥éª¤ï¼š</strong><br />
            1. ä¿æŒç›¸æœºä¸åŠ¨ (ä¸è¦æ—‹è½¬èƒŒæ™¯)ã€‚<br />
            2. åœ¨ç”»é¢ä¸­ç‚¹å‡» 3-5 ä¸ªä½ è®¤ä¸ºæ˜¯<b>ç­‰è·</b>çš„ä½ç½®ã€‚<br />
            3. ç‚¹å‡»ä¸‹æ–¹ç»¿è‰²æŒ‰é’®ã€‚
          </div>
          <div class="mode-switch">
            <button
              class="btn active"
              style="background: #27ae60"
              @click="runAutoTune"
            >
              âš¡ï¸ è‡ªåŠ¨è®¡ç®—å‚æ•°
            </button>
            <button class="btn inactive" @click="clearPoints">
              âŒ æ¸…é™¤ç‚¹ ({{ calibPoints.length }})
            </button>
          </div>
        </div>

        <div class="group">
          <div class="slider-header" style="color: #3498db; font-weight: bold">
            ç®—æ³•å‚æ•° (å¯å¾®è°ƒ)
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span>Geo Gamma (çºµå‘)</span
              ><span>{{ params.geoGamma.toFixed(2) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.geoGamma"
              min="0.1"
              max="2.0"
              step="0.05"
            />
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span>Horizontal Fix (æ¨ªå‘)</span
              ><span>{{ params.hCorrPower.toFixed(2) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.hCorrPower"
              min="0.0"
              max="3.0"
              step="0.1"
            />
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span>Global Scale</span
              ><span>{{ params.globalScale.toFixed(1) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.globalScale"
              min="1.0"
              max="20.0"
              step="0.1"
            />
          </div>
        </div>

        <hr style="border-color: #444" />
        <input type="file" accept="image/*" @change="e => loadFile(e, 'bg')" />
        <div style="font-size: 10px; color: #888; margin-bottom: 5px">
          1. Load Panorama
        </div>
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'depth')"
        />
        <div style="font-size: 10px; color: #888; margin-bottom: 5px">
          2. Load Depth Map
        </div>
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'char')"
        />
        <div style="font-size: 10px; color: #888; margin-bottom: 5px">
          3. Load Character
        </div>

        <div class="status-box" v-if="calibPoints.length > 0">
          å·²æ ‡è®°: {{ calibPoints.length }} ç‚¹<br />
          å½“å‰è¯¯å·®: {{ currentStdDev }}
        </div>
      </div>
    </div>

    <script>
      const { createApp, ref, reactive, onMounted, nextTick } = Vue;

      createApp({
        setup() {
          const viewer = ref(null);
          const depthCanvas = ref(null);
          const drawCanvas = ref(null);
          const depthCtx = ref(null);

          const bgSrc = ref(null);
          const charImgSrc = ref(null);
          const mode = ref("preview");

          const charPos = reactive({
            x: window.innerWidth / 2,
            y: window.innerHeight * 0.8,
          });
          const isDragging = ref(false);
          const currentScale = ref(1.0);

          // æ ¡å‡†ç‚¹ï¼šé¢å¤–å­˜å‚¨ screenX, screenY ç”¨äºç»˜å›¾
          const calibPoints = ref([]);
          const currentStdDev = ref("---");

          // å‚æ•°
          const params = reactive({
            geoGamma: 0.6,
            hCorrPower: 0.0,
            globalScale: 5.5,
            geoWeight: 0.8,
            baseWidth: 200, // é»˜è®¤å®½åº¦
          });

          // 1. æ ¸å¿ƒ Scale è®¡ç®—
          const calculateScale = (
            u,
            v,
            pitch,
            yaw,
            camYaw,
            p_gamma,
            p_h_power,
            p_global,
            p_weight,
            depth_val,
          ) => {
            const v_clamped = Math.max(v, 0.52);
            const raw_tan = Math.tan((v_clamped - 0.5) * Math.PI);
            const v_scale = Math.pow(raw_tan, p_gamma);

            let dYaw = Math.abs(yaw - camYaw);
            if (dYaw > 180) dYaw = 360 - dYaw;
            const dRad = dYaw * (Math.PI / 180.0);
            const safeRad = Math.min(dRad, 1.3); // é™åˆ¶æœ€å¤§è§’åº¦ï¼Œé˜²æ­¢é™¤ä»¥0
            const h_factor = 1.0 / Math.cos(safeRad);
            const final_h = Math.pow(h_factor, p_h_power);

            const geo_final = v_scale * final_h;

            const d_norm = depth_val / 255.0;
            const weight_d = 1.0 - p_weight;
            const mixed =
              depth_val === -1
                ? geo_final
                : geo_final * (p_weight + weight_d * d_norm);

            return mixed * p_global;
          };

          // 2. è‡ªåŠ¨è°ƒå‚ (æš´åŠ›æœç´¢)
          const runAutoTune = () => {
            if (calibPoints.value.length < 2) return alert("è‡³å°‘éœ€è¦ 2 ä¸ªç‚¹ï¼");

            // é¢„è¯»å–æ·±åº¦å€¼ï¼Œé¿å…å¾ªç¯ä¸­é‡å¤è¯»å–
            const pointsData = calibPoints.value.map((pt) => {
              let dVal = -1;
              if (depthCtx.value) {
                const px = Math.floor(pt.u * 1024);
                const py = Math.floor(pt.v * 512);
                dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
              }
              return { ...pt, dVal };
            });

            let bestError = Infinity;
            let bestG = params.geoGamma;
            let bestH = params.hCorrPower;

            // æœç´¢èŒƒå›´ï¼šGamma(0.1-1.5), H_Fix(0.0-3.0)
            for (let g = 0.1; g <= 1.5; g += 0.05) {
              for (let h = 0.0; h <= 3.0; h += 0.1) {
                const scales = pointsData.map((pt) => {
                  // æ³¨æ„ï¼šæ ¡å‡†æ—¶å‡è®¾ GlobalScale=1ï¼Œæˆ‘ä»¬åªå…³å¿ƒç›¸å¯¹ä¸€è‡´æ€§
                  return calculateScale(
                    pt.u,
                    pt.v,
                    pt.pitch,
                    pt.yaw,
                    pt.camYaw,
                    g,
                    h,
                    1.0,
                    params.geoWeight,
                    pt.dVal,
                  );
                });

                // è®¡ç®—å˜å¼‚ç³»æ•° (CV)
                const mean = scales.reduce((a, b) => a + b) / scales.length;
                const variance =
                  scales.reduce((a, b) => a + Math.pow(b - mean, 2), 0) /
                  scales.length;
                const stdDev = Math.sqrt(variance);
                const cv = stdDev / mean;

                if (cv < bestError) {
                  bestError = cv;
                  bestG = g;
                  bestH = h;
                }
              }
            }

            params.geoGamma = parseFloat(bestG.toFixed(2));
            params.hCorrPower = parseFloat(bestH.toFixed(2));

            // é‡æ–°è®¡ç®— StdDev ç”¨äºæ˜¾ç¤º
            calculateStdDev();
            alert(
              `âœ… ä¼˜åŒ–å®Œæˆï¼\nè¯¯å·®é™ä½è‡³: ${(bestError * 100).toFixed(2)}%`,
            );
          };

          // 3. ç‚¹å‡»æ ‡è®°é€»è¾‘
          const onClick = (e) => {
            // å¦‚æœæ˜¯æ‹–æ‹½é¢„è§ˆæ¨¡å¼ï¼Œæˆ–è€…åœ¨æ‹–åŠ¨è§’è‰²ï¼Œä¸æ ‡è®°
            if (mode.value !== "calibrate" || isDragging.value) return;

            // ç¡®ä¿ç‚¹å‡»çš„æ˜¯ Canvas/Container è€Œä¸æ˜¯æ§åˆ¶æ¿
            if (e.target.closest(".controls")) return;

            if (!viewer.value) return;
            const coords = viewer.value.mouseEventToCoords(e);
            if (!coords) return; // ç‚¹å‡»äº†æ— æ•ˆåŒºåŸŸ

            const pitch = coords[0];
            const yaw = coords[1];
            const camYaw = viewer.value.getYaw();

            let u = (yaw + 180) / 360.0;
            u = u % 1.0;
            if (u < 0) u += 1.0;
            let v = (90 - pitch) / 180.0;
            v = Math.max(0, Math.min(1, v));

            // è®°å½•ç‚¹ (åŒ…å«å±å¹•åæ ‡ x, y ç”¨äºç»˜å›¾)
            calibPoints.value.push({
              u,
              v,
              pitch,
              yaw,
              camYaw,
              screenX: e.clientX,
              screenY: e.clientY,
            });

            drawOverlay();
            calculateStdDev();
          };

          // 4. ç»˜å›¾ (ä¿®å¤ï¼šæ˜¾å¼ç”»çº¢åœˆ)
          const drawOverlay = () => {
            const cvs = drawCanvas.value;
            if (!cvs) return;
            const ctx = cvs.getContext("2d");

            // é‡ç½®ç”»å¸ƒå°ºå¯¸
            cvs.width = window.innerWidth;
            cvs.height = window.innerHeight;
            ctx.clearRect(0, 0, cvs.width, cvs.height);

            if (calibPoints.value.length === 0) return;

            // æ ·å¼
            ctx.lineWidth = 2;
            ctx.font = "bold 14px Arial";

            // ç”»è¿çº¿
            ctx.beginPath();
            ctx.strokeStyle = "rgba(52, 152, 219, 0.6)"; // è“çº¿
            calibPoints.value.forEach((pt, i) => {
              if (i === 0) ctx.moveTo(pt.screenX, pt.screenY);
              else ctx.lineTo(pt.screenX, pt.screenY);
            });
            ctx.stroke();

            // ç”»ç‚¹
            calibPoints.value.forEach((pt, i) => {
              ctx.beginPath();
              ctx.fillStyle = "#e74c3c"; // çº¢ç‚¹
              ctx.strokeStyle = "#fff";
              ctx.arc(pt.screenX, pt.screenY, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();

              // ç”»åºå·
              ctx.fillStyle = "#fff";
              ctx.fillText(i + 1, pt.screenX + 10, pt.screenY - 10);
            });
          };

          // è®¡ç®—å½“å‰æ–¹å·® (ä»…å±•ç¤ºç”¨)
          const calculateStdDev = () => {
            if (calibPoints.value.length < 2) return;
            const pointsData = calibPoints.value.map((pt) => {
              let dVal = -1;
              if (depthCtx.value) {
                const px = Math.floor(pt.u * 1024);
                const py = Math.floor(pt.v * 512);
                dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
              }
              return calculateScale(
                pt.u,
                pt.v,
                pt.pitch,
                pt.yaw,
                pt.camYaw,
                params.geoGamma,
                params.hCorrPower,
                params.globalScale,
                params.geoWeight,
                dVal,
              );
            });

            const mean = pointsData.reduce((a, b) => a + b) / pointsData.length;
            const variance =
              pointsData.reduce((a, b) => a + Math.pow(b - mean, 2), 0) /
              pointsData.length;
            const cv = Math.sqrt(variance) / mean;
            currentStdDev.value = (cv * 100).toFixed(2) + "%";
          };

          const clearPoints = () => {
            calibPoints.value = [];
            drawOverlay();
            currentStdDev.value = "---";
          };

          // --- å¸¸è§„é€»è¾‘ ---
          const updatePreview = () => {
            if (!viewer.value) return;
            const mockEvent = {
              clientX: charPos.x,
              clientY: charPos.y,
              target: viewer.value.getContainer(),
            };
            const coords = viewer.value.mouseEventToCoords(mockEvent);
            if (!coords) return;

            const pitch = coords[0];
            const yaw = coords[1];
            let u = (yaw + 180) / 360.0;
            u = u % 1.0;
            if (u < 0) u += 1.0;
            let v = (90 - pitch) / 180.0;
            v = Math.max(0, Math.min(1, v));

            // å®æ—¶è®¡ç®—éœ€è¦ç”¨å½“å‰çš„ Camera Yaw
            const camYaw = viewer.value.getYaw();

            let dVal = 128;
            if (depthCtx.value) {
              const px = Math.floor(u * 1024);
              const py = Math.floor(v * 512);
              dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
            }

            currentScale.value = calculateScale(
              u,
              v,
              pitch,
              yaw,
              camYaw,
              params.geoGamma,
              params.hCorrPower,
              params.globalScale,
              params.geoWeight,
              dVal,
            );
          };

          // åŠ è½½é€»è¾‘
          const loadFile = (e, type) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
              const res = ev.target.result;
              if (type === "bg") initViewer(res);
              else if (type === "char") charImgSrc.value = res;
              else if (type === "depth") initDepthCanvas(res);
            };
            reader.readAsDataURL(file);
          };

          const initViewer = (src) => {
            if (viewer.value) viewer.value.destroy();
            viewer.value = pannellum.viewer("panorama", {
              type: "equirectangular",
              panorama: src,
              autoLoad: true,
              showZoomCtrl: false,
              pitch: -20,
            });
            viewer.value.on("animate", updatePreview);
            viewer.value.on("mouseup", updatePreview);

            // ç»‘å®šç‚¹å‡»ï¼šéœ€è¦ç»‘å®šåˆ° container ä¸Š
            nextTick(() => {
              const container = document.getElementById("drawing-layer"); // ç»‘å®šåˆ°é¡¶å±‚ Canvas ä¸Š
              container.addEventListener("mousedown", onClick);
            });
          };

          const initDepthCanvas = (src) => {
            const img = new Image();
            img.onload = () => {
              const cvs = depthCanvas.value;
              cvs.width = 1024;
              cvs.height = 512;
              const ctx = cvs.getContext("2d", { willReadFrequently: true });
              ctx.drawImage(img, 0, 0, 1024, 512);
              depthCtx.value = ctx;
            };
            img.src = src;
          };

          const setMode = (m) => {
            mode.value = m;
            if (m === "calibrate") clearPoints(); // åˆ‡æ¢æ—¶æ¸…ç©ºï¼Œé˜²æ­¢åæ ‡é”™ä¹±
          };

          const startDrag = () => (isDragging.value = true);
          const stopDrag = () => (isDragging.value = false);
          const handleMouseMove = (e) => {
            if (isDragging.value) {
              charPos.x = e.clientX;
              charPos.y = e.clientY;
              updatePreview();
            }
          };

          onMounted(() => {
            window.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", stopDrag);
            window.addEventListener("resize", drawOverlay); // çª—å£è°ƒæ•´æ—¶é‡ç»˜
          });

          return {
            loadFile,
            charImgSrc,
            charPos,
            mode,
            setMode,
            params,
            currentScale,
            startDrag,
            calibPoints,
            clearPoints,
            runAutoTune,
            currentStdDev,
            depthCanvas,
            drawCanvas,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
