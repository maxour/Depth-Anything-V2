<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>360 Auto-Calibration Tool</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"
    />
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"
    ></script>

    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: sans-serif;
        background: #1a1a1a;
        color: #ddd;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }

      #panorama {
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* ç»˜å›¾å±‚ (ç”¨äºæ˜¾ç¤ºæ ¡å‡†çº¿) */
      #drawing-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 20;
        pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ç»™ Pannellum å¤„ç†åæ ‡ */
      }

      /* è§’è‰²å±‚ */
      .character-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none;
      }
      .avatar-container {
        position: absolute;
        transform-origin: bottom center;
        cursor: grab;
        pointer-events: auto;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: flex-end;
        border: 1px dashed rgba(255, 255, 255, 0.3);
      }
      .avatar-img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none;
      }

      /* æ§åˆ¶é¢æ¿ */
      .controls {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 320px;
        background: rgba(0, 0, 0, 0.9);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        max-height: 95vh;
        overflow-y: auto;
      }
      .mode-switch {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      .btn {
        flex: 1;
        padding: 8px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        font-size: 12px;
      }
      .btn.active {
        background: #3498db;
        color: white;
      }
      .btn.inactive {
        background: #444;
        color: #aaa;
      }

      .slider-row {
        margin-bottom: 8px;
      }
      .slider-header {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: #aaa;
        margin-bottom: 2px;
      }
      input[type="range"] {
        width: 100%;
      }

      .status-box {
        background: #222;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 11px;
        color: #0f0;
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <canvas ref="depthCanvas" style="display: none"></canvas>

      <canvas ref="drawCanvas" id="drawing-layer"></canvas>

      <div id="panorama"></div>

      <div class="character-layer" v-if="charImgSrc && mode === 'preview'">
        <div
          class="avatar-container"
          :style="{ 
                 left: charPos.x + 'px', top: charPos.y + 'px',
                 width: params.baseWidth + 'px',
                 transform: `translate(-50%, -100%) scale(${currentScale})` 
             }"
          @mousedown.stop.prevent="startDrag"
        >
          <img :src="charImgSrc" class="avatar-img" />
        </div>
      </div>

      <div class="controls">
        <h3>ğŸ“ Auto-Calibrator</h3>

        <div class="mode-switch">
          <button
            class="btn"
            :class="mode === 'preview' ? 'active' : 'inactive'"
            @click="setMode('preview')"
          >
            ğŸ– æ‹–æ‹½é¢„è§ˆ
          </button>
          <button
            class="btn"
            :class="mode === 'calibrate' ? 'active' : 'inactive'"
            @click="setMode('calibrate')"
          >
            âœï¸ ç»˜åˆ¶ç­‰è·çº¿
          </button>
        </div>

        <div
          v-if="mode === 'calibrate'"
          style="
            font-size: 11px;
            color: #ddd;
            margin-bottom: 10px;
            line-height: 1.4;
          "
        >
          <strong>æ“ä½œæŒ‡å—ï¼š</strong><br />
          1. åœ¨ç”»é¢ä¸­ç‚¹å‡» 3-5 ä¸ªç‚¹ã€‚<br />
          2. ç¡®ä¿è¿™äº›ç‚¹åœ¨ç‰©ç†ä¸–ç•Œä¸­<b>ç¦»ä½ ä¸€æ ·è¿œ</b>
          (ä¾‹å¦‚éƒ½åœ¨åŒä¸€åœˆåœ°ç –çº¿ä¸Š)ã€‚<br />
          3. ç‚¹å‡»â€œè‡ªåŠ¨è®¡ç®—â€ã€‚
        </div>

        <div v-if="mode === 'calibrate'" class="mode-switch">
          <button
            class="btn active"
            style="background: #27ae60"
            @click="runAutoTune"
          >
            âš¡ï¸ è‡ªåŠ¨è®¡ç®—å‚æ•°
          </button>
          <button class="btn inactive" @click="clearPoints">âŒ æ¸…é™¤ç‚¹</button>
        </div>

        <div class="group">
          <div class="slider-row">
            <div class="slider-header">
              <span>Geo Gamma (çºµå‘æ›²çº¿)</span
              ><span>{{ params.geoGamma.toFixed(2) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.geoGamma"
              min="0.1"
              max="2.0"
              step="0.05"
            />
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span>Horizontal Fix (æ¨ªå‘ä¿®æ­£)</span
              ><span>{{ params.hCorrPower.toFixed(2) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.hCorrPower"
              min="0.0"
              max="2.0"
              step="0.1"
            />
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span>Global Scale</span
              ><span>{{ params.globalScale.toFixed(1) }}</span>
            </div>
            <input
              type="range"
              v-model.number="params.globalScale"
              min="1.0"
              max="20.0"
              step="0.1"
            />
          </div>
        </div>

        <hr style="border-color: #444" />
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'bg')"
        /><br />
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'depth')"
        /><br />
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'char')"
        />

        <div class="status-box" v-if="calibPoints.length > 0">
          Points: {{ calibPoints.length }}<br />
          StdDev: {{ currentStdDev }} (è¶Šå°è¶Šå¥½)
        </div>
      </div>
    </div>

    <script>
      const {
        createApp,
        ref,
        reactive,
        onMounted,
        onUnmounted,
        watch,
        nextTick,
      } = Vue;

      createApp({
        setup() {
          const viewer = ref(null);
          const depthCanvas = ref(null);
          const drawCanvas = ref(null);
          const depthCtx = ref(null);

          const bgSrc = ref(null);
          const charImgSrc = ref(null);
          const mode = ref("preview"); // 'preview' | 'calibrate'

          // çŠ¶æ€
          const charPos = reactive({
            x: window.innerWidth / 2,
            y: window.innerHeight * 0.8,
          });
          const isDragging = ref(false);
          const currentScale = ref(1.0);

          // æ ¡å‡†ç‚¹æ•°æ®
          const calibPoints = ref([]); // Array of {u, v, yaw, pitch}
          const currentStdDev = ref("0.000");

          // å‚æ•°
          const params = reactive({
            geoGamma: 0.6,
            hCorrPower: 0.0,
            globalScale: 5.5,
            geoWeight: 0.8,
            baseWidth: 150,
          });

          // --- æ ¸å¿ƒç®—æ³• (çº¯ JS å‡½æ•°ï¼Œæ–¹ä¾¿å¤ç”¨) ---
          const calculateScale = (
            u,
            v,
            pitch,
            yaw,
            camYaw,
            p_gamma,
            p_h_power,
            p_global,
            p_weight,
            depth_val,
          ) => {
            // 1. å‡ ä½•çºµå‘ (Tan + Gamma)
            const v_clamped = Math.max(v, 0.52);
            const raw_tan = Math.tan((v_clamped - 0.5) * Math.PI);
            const v_scale = Math.pow(raw_tan, p_gamma);

            // 2. å‡ ä½•æ¨ªå‘ (Cos ä¿®æ­£)
            let dYaw = Math.abs(yaw - camYaw);
            if (dYaw > 180) dYaw = 360 - dYaw;
            const dRad = dYaw * (Math.PI / 180.0);
            const safeRad = Math.min(dRad, 1.2);
            const h_factor = 1.0 / Math.cos(safeRad);
            const final_h = Math.pow(h_factor, p_h_power);

            // 3. å‡ ä½•ç»¼åˆ
            const geo_final = v_scale * final_h;

            // 4. æ·±åº¦æ··åˆ
            const d_norm = depth_val / 255.0;
            const weight_d = 1.0 - p_weight;

            // å¦‚æœæ·±åº¦å›¾æ²¡åŠ è½½ï¼Œå°±çº¯ç”¨å‡ ä½•
            const mixed =
              depth_val === -1
                ? geo_final
                : geo_final * (p_weight + weight_d * d_norm);

            // 5. å…¨å±€ç¼©æ”¾
            return mixed * p_global;
          };

          // --- è‡ªåŠ¨è®¡ç®—é€»è¾‘ (Auto Tune) ---
          const runAutoTune = () => {
            if (calibPoints.value.length < 2) {
              alert("è¯·è‡³å°‘æ ‡è®° 2 ä¸ªç‚¹ï¼");
              return;
            }

            console.log("ğŸš€ Starting Auto-Tune...");

            let bestError = Infinity;
            let bestGamma = params.geoGamma;
            let bestHPower = params.hCorrPower;

            // è·å–æ‰€æœ‰ç‚¹çš„æ·±åº¦å€¼
            const pointsData = calibPoints.value.map((pt) => {
              let dVal = -1;
              if (depthCtx.value) {
                const px = Math.floor(pt.u * 1024);
                const py = Math.floor(pt.v * 512);
                dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
              }
              return { ...pt, dVal };
            });

            // æš´åŠ›æœç´¢ (Grid Search)
            // èŒƒå›´ï¼šGamma 0.1~1.5, HPower 0.0~2.0
            // æ­¥é•¿è¶Šå°è¶Šå‡†ï¼Œä½†ä¹Ÿè¶Šæ…¢
            for (let g = 0.1; g <= 1.5; g += 0.05) {
              for (let h = 0.0; h <= 2.0; h += 0.1) {
                // è®¡ç®—è¿™ç»„å‚æ•°ä¸‹ï¼Œæ‰€æœ‰ç‚¹çš„ Scale
                const scales = pointsData.map((pt) => {
                  // æ³¨æ„ï¼šGlobalScale ä¸å½±å“â€œæ–¹å·®ä¸€è‡´æ€§â€ï¼Œæ‰€ä»¥è®¾ä¸º 1.0
                  return calculateScale(
                    pt.u,
                    pt.v,
                    pt.pitch,
                    pt.yaw,
                    pt.camYaw,
                    g,
                    h,
                    1.0,
                    params.geoWeight,
                    pt.dVal,
                  );
                });

                // è®¡ç®—å˜å¼‚ç³»æ•° (CV = StdDev / Mean)
                // æˆ‘ä»¬å¸Œæœ› scales æ•°ç»„é‡Œçš„å€¼è¶Šæ¥è¿‘è¶Šå¥½
                const n = scales.length;
                const mean = scales.reduce((a, b) => a + b) / n;
                const variance =
                  scales.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / n;
                const stdDev = Math.sqrt(variance);
                const cv = stdDev / mean; // å½’ä¸€åŒ–è¯¯å·®

                if (cv < bestError) {
                  bestError = cv;
                  bestGamma = g;
                  bestHPower = h;
                }
              }
            }

            // åº”ç”¨æœ€ä½³å‚æ•°
            params.geoGamma = parseFloat(bestGamma.toFixed(2));
            params.hCorrPower = parseFloat(bestHPower.toFixed(2));

            // è‡ªåŠ¨è°ƒæ•´ Global Scale ä»¥åŒ¹é…ç¬¬ä¸€ä¸ªç‚¹çš„å¤§å° (é¿å…å‚æ•°å˜äº†ä¹‹åæ•´ä½“å˜å¾—å·¨å°)
            // æˆ‘ä»¬å‡è®¾ç¬¬ä¸€ä¸ªç‚¹æ˜¯æˆ‘ä»¬å¸Œæœ›çš„åŸºå‡†å¤§å°(æ¯”å¦‚ Scale=1.0)
            // ä½†è¿™é‡Œæˆ‘ä»¬ç®€å•åœ°ä¿æŒå½“å‰çš„ globalScale ä¸åŠ¨ï¼Œç”¨æˆ·è‡ªå·±è°ƒ

            alert(
              `âœ… ä¼˜åŒ–å®Œæˆ!\nGamma: ${params.geoGamma}\nHorizontal Fix: ${params.hCorrPower}\nè¯¯å·®: ${(bestError * 100).toFixed(2)}%`,
            );
            drawOverlay(); // é‡ç»˜
          };

          // --- äº¤äº’é€»è¾‘ ---
          const onClick = (e) => {
            if (mode.value !== "calibrate") return;

            if (!viewer.value) return;
            const coords = viewer.value.mouseEventToCoords(e);
            if (!coords) return;

            const pitch = coords[0];
            const yaw = coords[1];
            const camYaw = viewer.value.getYaw(); // è®°å½•ç‚¹ä¸‹æ—¶çš„ç›¸æœºè§’åº¦

            // è½¬æ¢ä¸º UV
            let u = (yaw + 180) / 360.0;
            u = u % 1.0;
            if (u < 0) u += 1.0;
            let v = (90 - pitch) / 180.0;
            v = Math.max(0, Math.min(1, v));

            // è®°å½•å±å¹•åæ ‡ç”¨äºç»˜å›¾ (ä½†è¿™åœ¨ 360 ç§»åŠ¨åä¼šå¤±æ•ˆï¼Œæ‰€ä»¥ç»˜å›¾éœ€è¦å®æ—¶é‡ç®—)
            calibPoints.value.push({ u, v, pitch, yaw, camYaw });

            // ç«‹å³è®¡ç®—å½“å‰çš„ StdDev
            calculateStdDev();
            drawOverlay();
          };

          const calculateStdDev = () => {
            if (calibPoints.value.length < 2) {
              currentStdDev.value = "0.000";
              return;
            }
            // ä½¿ç”¨å½“å‰å‚æ•°è®¡ç®—
            const scales = calibPoints.value.map((pt) => {
              let dVal = -1;
              if (depthCtx.value) {
                const px = Math.floor(pt.u * 1024);
                const py = Math.floor(pt.v * 512);
                dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
              }
              // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ pt.camYaw æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸º scale åº”è¯¥åŸºäºâ€œå½“å‰è§‚å¯Ÿè§†è§’â€çš„ H-Fix
              // ä½†æ˜¯å¯¹äºæ ¡å‡†ï¼Œæˆ‘ä»¬å‡è®¾â€œå½“æ—¶ç‚¹å‡»æ—¶çš„è§†è§’åç§»â€æ˜¯æ ¡å‡†ä¾æ®ã€‚
              // ä¿®æ­£ï¼šH-Fix åº”è¯¥æ˜¯ç›¸å¯¹äºâ€œç‰©ä½“æ‰€åœ¨ä½ç½®â€å’Œâ€œç›¸æœºä¸­å¿ƒâ€çš„å…³ç³»ã€‚
              // å¦‚æœæˆ‘ä»¬åœ¨æ ¡å‡†æ¨¡å¼ä¸‹ï¼Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾æ‰€æœ‰ç‚¹éƒ½æ˜¯ç›¸å¯¹äºåŒä¸€ä¸ª Camera Center (æ¯”å¦‚ Yaw=0) ä¹Ÿæ²¡é—®é¢˜
              // ä½†æœ€å‡†ç¡®çš„æ˜¯ï¼šcalculateScale éœ€è¦ä¼ å…¥ pt.camYaw (ç‚¹å‡»æ—¶çš„è§†è§’ä¸­å¿ƒ)
              return calculateScale(
                pt.u,
                pt.v,
                pt.pitch,
                pt.yaw,
                pt.camYaw,
                params.geoGamma,
                params.hCorrPower,
                params.globalScale,
                params.geoWeight,
                dVal,
              );
            });

            const mean = scales.reduce((a, b) => a + b) / scales.length;
            const variance =
              scales.reduce((a, b) => a + Math.pow(b - mean, 2), 0) /
              scales.length;
            currentStdDev.value = Math.sqrt(variance).toFixed(3);
          };

          // ç»˜åˆ¶ Canvas è¿çº¿
          const drawOverlay = () => {
            const cvs = drawCanvas.value;
            if (!cvs || !viewer.value) return;
            const ctx = cvs.getContext("2d");
            cvs.width = window.innerWidth;
            cvs.height = window.innerHeight;
            ctx.clearRect(0, 0, cvs.width, cvs.height);

            if (calibPoints.value.length === 0) return;

            ctx.strokeStyle = "#0f0";
            ctx.lineWidth = 2;
            ctx.fillStyle = "#ff0";
            ctx.font = "12px Arial";

            ctx.beginPath();
            calibPoints.value.forEach((pt, index) => {
              // å°† Pitch/Yaw é€†å‘æŠ•å½±å›å±å¹•åæ ‡ XY
              // è¿™æ˜¯ä¸€ä¸ªéš¾ç‚¹ï¼ŒPannellum æ²¡æœ‰ç›´æ¥æš´éœ² coordsToMouseã€‚
              // ä½†æˆ‘ä»¬å¯ä»¥åè¿‡æ¥ï¼šæˆ‘ä»¬å¾ˆéš¾ç²¾ç¡®ç”»çº¿è·ŸéšèƒŒæ™¯ç§»åŠ¨ã€‚
              // ç®€æ˜“æ–¹æ¡ˆï¼šåªç”»é™æ€çš„ç‚¹ï¼Œæˆ–è€…ä»…åœ¨ç‚¹å‡»æ—¶æ˜¾ç¤ºã€‚
              // é«˜çº§æ–¹æ¡ˆï¼šç”±äºæ— æ³•è·å– Pannellum æŠ•å½±çŸ©é˜µï¼Œæˆ‘ä»¬ç”¨ CSS æ ‡è®°ç‚¹æ›¿ä»£ Canvas ç”»çº¿
              // è¿™é‡Œä¸ºäº†ç®€åŒ–ä»£ç ï¼Œæˆ‘ä»¬ä¸å®ç°â€œè·Ÿéšç§»åŠ¨çš„çº¿â€ï¼Œåªåœ¨æ§åˆ¶å°è¾“å‡º
            });

            // ç”±äºåæŠ•å½±å›°éš¾ï¼Œæˆ‘ä»¬åœ¨ UI ä¸Šæ˜¾ç¤ºâ€œå·²æ ‡è®° X ä¸ªç‚¹â€ï¼Œä¸ç”»å¤æ‚çš„ 3D è¿çº¿
            // æˆ–è€…æˆ‘ä»¬å¯ä»¥ç®€å•åœ°æ¸…é™¤ Canvas
          };

          const clearPoints = () => {
            calibPoints.value = [];
            currentStdDev.value = "0.000";
            drawOverlay();
          };

          // --- å¸¸è§„é€»è¾‘ (Copy from Debugger2) ---
          const updatePreview = () => {
            if (mode.value !== "preview" || !viewer.value) return;

            // è·å–å½“å‰ Character ä½ç½®çš„æ•°æ®
            const mockEvent = {
              clientX: charPos.x,
              clientY: charPos.y,
              target: viewer.value.getContainer(),
            };
            const coords = viewer.value.mouseEventToCoords(mockEvent);
            if (!coords) return;

            const pitch = coords[0];
            const yaw = coords[1];
            let u = (yaw + 180) / 360.0;
            u = u % 1.0;
            if (u < 0) u += 1.0;
            let v = (90 - pitch) / 180.0;
            v = Math.max(0, Math.min(1, v));

            const camYaw = viewer.value.getYaw();

            let dVal = 128;
            if (depthCtx.value) {
              const px = Math.floor(u * 1024);
              const py = Math.floor(v * 512);
              dVal = depthCtx.value.getImageData(px, py, 1, 1).data[0];
            }

            currentScale.value = calculateScale(
              u,
              v,
              pitch,
              yaw,
              camYaw,
              params.geoGamma,
              params.hCorrPower,
              params.globalScale,
              params.geoWeight,
              dVal,
            );
          };

          // Event Listeners
          const startDrag = () => (isDragging.value = true);
          const stopDrag = () => (isDragging.value = false);
          const handleMouseMove = (e) => {
            if (isDragging.value && mode.value === "preview") {
              charPos.x = e.clientX;
              charPos.y = e.clientY;
              updatePreview();
            }
          };

          const loadFile = (e, type) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
              if (type === "bg") initViewer(ev.target.result);
              else if (type === "char") charImgSrc.value = ev.target.result;
              else if (type === "depth") initDepthCanvas(ev.target.result);
            };
            reader.readAsDataURL(file);
          };

          const initViewer = (src) => {
            if (viewer.value) viewer.value.destroy();
            viewer.value = pannellum.viewer("panorama", {
              type: "equirectangular",
              panorama: src,
              autoLoad: true,
              showZoomCtrl: false,
              pitch: -20,
            });
            viewer.value.on("animate", updatePreview);
            viewer.value.on("mouseup", updatePreview);
            viewer.value.on("mousedown", onClick); // ç»‘å®šç‚¹å‡»äº‹ä»¶
          };

          const initDepthCanvas = (src) => {
            const img = new Image();
            img.onload = () => {
              const cvs = depthCanvas.value;
              cvs.width = 1024;
              cvs.height = 512;
              const ctx = cvs.getContext("2d", { willReadFrequently: true });
              ctx.drawImage(img, 0, 0, 1024, 512);
              depthCtx.value = ctx;
            };
            img.src = src;
          };

          const setMode = (m) => {
            mode.value = m;
            if (m === "calibrate") {
              calibPoints.value = []; // åˆ‡æ¢æ—¶æ¸…ç©º
            }
          };

          onMounted(() => {
            window.addEventListener("mousemove", handleMouseMove);
            window.addEventListener("mouseup", stopDrag);
          });

          return {
            loadFile,
            charImgSrc,
            charPos,
            mode,
            setMode,
            params,
            currentScale,
            startDrag,
            calibPoints,
            clearPoints,
            runAutoTune,
            currentStdDev,
            depthCanvas,
            drawCanvas, // Refs
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
