<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>360 Avatar Drag & Scale</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"
    />
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"
    ></script>

    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: sans-serif;
        background: #222;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }

      /* 1. 360 æ’­æ”¾å™¨å±‚ */
      #panorama {
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* 2. Character å±‚ */
      .character-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none; /* è®©é¼ æ ‡ç©¿é€ç©ºç™½åŒºåŸŸ */
      }

      .avatar-container {
        position: absolute;
        transform-origin: bottom center; /* å…³é”®ï¼šç¼©æ”¾ä¸­å¿ƒåœ¨è„šåº• */
        cursor: grab;
        pointer-events: auto; /* å…è®¸æ•è·é¼ æ ‡äº‹ä»¶ */
        user-select: none;
        /* è™šçº¿æ¡†æ–¹ä¾¿è°ƒè¯•ï¼Œå®é™…ä½¿ç”¨å¯å»æ‰ */
        border: 2px dashed rgba(255, 255, 0, 0.3);
        display: flex;
        justify-content: center;
        align-items: flex-end;
      }
      .avatar-container.dragging {
        cursor: grabbing;
        border-color: #00ff00;
      }
      .avatar-img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none;
      }

      /* 3. UI æ§åˆ¶é¢æ¿ */
      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 300px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
      }
      .row {
        margin-bottom: 8px;
        font-size: 13px;
        display: flex;
        justify-content: space-between;
      }
      .val {
        color: #0f0;
        font-family: monospace;
      }
      input[type="file"] {
        width: 100%;
        font-size: 11px;
        margin-bottom: 5px;
      }

      /* å‡†æ˜Ÿ */
      .crosshair {
        position: absolute;
        width: 8px;
        height: 8px;
        background: red;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 20;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="panorama"></div>

      <div class="character-layer" v-if="charImgSrc">
        <div
          class="avatar-container"
          :class="{ dragging: isDragging }"
          :style="{ 
                 left: charPos.x + 'px', 
                 top: charPos.y + 'px',
                 width: baseWidth + 'px',
                 transform: `translate(-50%, -100%) scale(${currentScale})` 
             }"
          @mousedown.stop.prevent="startDrag"
        >
          <img :src="charImgSrc" class="avatar-img" />
        </div>
        <div
          class="crosshair"
          :style="{ left: charPos.x + 'px', top: charPos.y + 'px' }"
        ></div>
      </div>

      <div class="controls">
        <h3>ğŸ”§ Scene Debugger</h3>
        <input type="file" accept="image/*" @change="e => loadFile(e, 'bg')" />
        <div style="font-size: 10px; color: #aaa">1. Load Panorama (JPG)</div>
        <br />
        <input
          type="file"
          accept="application/json"
          @change="e => loadFile(e, 'json')"
        />
        <div style="font-size: 10px; color: #aaa">2. Load Meta JSON</div>
        <br />
        <input
          type="file"
          accept="image/*"
          @change="e => loadFile(e, 'char')"
        />
        <div style="font-size: 10px; color: #aaa">3. Load Character (PNG)</div>

        <hr style="border-color: #444" />

        <div v-if="navMesh">
          <div class="row">
            <span>Scale:</span
            ><span class="val">{{ currentScale.toFixed(3) }}</span>
          </div>
          <div class="row">
            <span>Depth:</span><span class="val">{{ currentDepthVal }}</span>
          </div>
          <div class="row">
            <span>Base Size:</span
            ><input
              type="range"
              v-model.number="baseWidth"
              min="50"
              max="400"
            />
          </div>
        </div>
        <div v-else style="color: yellow; font-size: 12px">
          âš ï¸ Please load JSON to enable scaling
        </div>
      </div>
    </div>

    <script>
      const { createApp, ref, reactive, onMounted, onUnmounted } = Vue;

      createApp({
        setup() {
          const viewer = ref(null);
          const navMesh = ref(null);
          const bgSrc = ref(null);
          const charImgSrc = ref(null);

          // Character State
          const charPos = reactive({
            x: window.innerWidth / 2,
            y: window.innerHeight * 0.8,
          });
          const isDragging = ref(false);
          const baseWidth = ref(150);

          // Metrics
          const currentScale = ref(1.0);
          const currentDepthVal = ref(0);
          let gridData = null; // ç¼“å­˜ç½‘æ ¼æ•°æ®

          // --- 1. æ–‡ä»¶åŠ è½½é€»è¾‘ ---
          const loadFile = (event, type) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
              if (type === "bg") initViewer(e.target.result);
              else if (type === "char") charImgSrc.value = e.target.result;
              else if (type === "json") {
                try {
                  const json = JSON.parse(e.target.result);
                  navMesh.value = json.nav_mesh || json;
                  processGridData();
                } catch (err) {
                  alert("JSON Error");
                }
              }
            };
            if (type === "json") reader.readAsText(file);
            else reader.readAsDataURL(file);
          };

          // --- 2. Pannellum åˆå§‹åŒ– ---
          const initViewer = (imageSrc) => {
            if (viewer.value) viewer.value.destroy();
            viewer.value = pannellum.viewer("panorama", {
              type: "equirectangular",
              panorama: imageSrc,
              autoLoad: true,
              compass: false,
              showZoomCtrl: false,
              mouseZoom: false,
              pitch: -20,
            });

            // ç›‘å¬è§†è§’è½¬åŠ¨ (èƒŒæ™¯åŠ¨ -> äººä¸åŠ¨ -> ç›¸å¯¹ä½ç½®å˜äº† -> Scaleå˜)
            viewer.value.on("animate", updateScaleFromScreenPos);
            viewer.value.on("mouseup", updateScaleFromScreenPos);
          };

          // --- 3. æ ¸å¿ƒï¼šæ‹–æ‹½é€»è¾‘ (Global Listeners) ---
          const startDrag = (e) => {
            isDragging.value = true;
            // å¯é€‰ï¼šè®°å½•ç‚¹å‡»åç§»é‡ï¼Œè¿™é‡Œç®€åŒ–ä¸ºç›´æ¥è·Ÿéšä¸­å¿ƒ
          };

          const handleDrag = (e) => {
            if (!isDragging.value) return;

            // 1. æ›´æ–° Character å±å¹•åæ ‡
            charPos.x = e.clientX;
            charPos.y = e.clientY;

            // 2. ğŸ”¥ å…³é”®ï¼šæ‹–åŠ¨æ—¶ç«‹å³è®¡ç®—æ–°çš„ Scale
            updateScaleFromScreenPos();
          };

          const stopDrag = () => {
            isDragging.value = false;
          };

          // ç»‘å®šåˆ° window ä»¥é˜²é¼ æ ‡ç§»å‡ºæµè§ˆå™¨æˆ– div
          onMounted(() => {
            window.addEventListener("mousemove", handleDrag);
            window.addEventListener("mouseup", stopDrag);
          });
          onUnmounted(() => {
            window.removeEventListener("mousemove", handleDrag);
            window.removeEventListener("mouseup", stopDrag);
          });

          // --- 4. ç®—æ³•ï¼šå±å¹•åæ ‡ -> JSONç½‘æ ¼ -> Scale ---
          const processGridData = () => {
            if (!navMesh.value) return;
            const mesh = navMesh.value;
            // å°†çº¿æ€§æ•°ç»„è½¬ä¸ºäºŒç»´çŸ©é˜µï¼Œæ–¹ä¾¿æŸ¥è¯¢
            const grid = Array(mesh.rows)
              .fill(0)
              .map(() => Array(mesh.cols).fill(null));
            mesh.points.forEach((pt) => {
              const c = pt.grid_pos[0];
              const r = pt.grid_pos[1];
              if (r < mesh.rows && c < mesh.cols) grid[r][c] = pt;
            });
            gridData = grid;
            updateScaleFromScreenPos();
          };

          const updateScaleFromScreenPos = () => {
            if (!viewer.value || !gridData) return;

            // A. æ¨¡æ‹Ÿç‚¹å‡»äº‹ä»¶è·å–çƒåæ ‡ (Pitch/Yaw)
            // è¿™é‡Œçš„ charPos.x/y æ—¢å¯ä»¥æ˜¯é¼ æ ‡ä½ç½®(æ‹–åŠ¨æ—¶)ï¼Œä¹Ÿå¯ä»¥æ˜¯å›ºå®šä½ç½®(è½¬èƒŒæ™¯æ—¶)
            const mockEvent = {
              clientX: charPos.x,
              clientY: charPos.y,
              target: viewer.value.getContainer(),
            };

            // Pannellum å†…éƒ¨åæŠ•å½±
            const coords = viewer.value.mouseEventToCoords(mockEvent);
            if (!coords || coords.length < 2) return; // é¼ æ ‡å¯èƒ½åœ¨ç”»å¸ƒå¤–

            const pitch = coords[0];
            const yaw = coords[1];

            // B. çƒåæ ‡ -> UV åæ ‡
            // U: Yaw -180~180 -> 0~1
            let u = (yaw + 180) / 360.0;
            // V: Pitch 90(å¤©)~-90(åœ°) -> 0~1
            let v = (90 - pitch) / 180.0;

            // å½’ä¸€åŒ–
            u = u % 1.0;
            if (u < 0) u += 1.0;
            v = Math.max(0, Math.min(1, v));

            // C. æŸ¥è¡¨æ’å€¼
            calculateBilinearScale(u, v);
          };

          const calculateBilinearScale = (u, v) => {
            const { rows, cols } = navMesh.value;
            // ç¡¬ç¼–ç  Python ä¸­ç”Ÿæˆçš„ç½‘æ ¼èŒƒå›´ (å¦‚æœä¸åŒ¹é…ä¼šå¯¼è‡´é”™ä½)
            // å»ºè®®åç»­å°†è¿™äº› range ä¹Ÿå†™å…¥ JSON
            const V_START = 0.55;
            const V_END = 0.95;

            // è¶Šç•Œå¤„ç†
            if (v < V_START) {
              currentScale.value = 0.15;
              return;
            } // å¤ªè¿œäº†
            if (v > V_END) {
              currentScale.value = 2.5;
              return;
            } // å¤ªè¿‘äº†

            // è®¡ç®— Grid æµ®ç‚¹ç´¢å¼•
            const u_ratio = u; // 0~1
            const v_ratio = (v - V_START) / (V_END - V_START); // 0~1æ˜ å°„åˆ°ç½‘æ ¼åŒºåŸŸ

            let c_float = u_ratio * cols;
            let r_float = v_ratio * (rows - 1);

            // è·å–å››ä¸ªé‚»è¿‘ç‚¹
            let c0 = Math.floor(c_float) % cols;
            let c1 = (c0 + 1) % cols;
            let r0 = Math.floor(r_float);
            let r1 = Math.min(r0 + 1, rows - 1);

            // æƒé‡
            let w_c = c_float - Math.floor(c_float);
            let w_r = r_float - Math.floor(r_float);

            const p00 = gridData[r0][c0];
            const p01 = gridData[r0][c1];
            const p10 = gridData[r1][c0];
            const p11 = gridData[r1][c1];

            if (!p00 || !p11) return;

            // åŒçº¿æ€§æ’å€¼ Scale
            const s_top = p00.scale * (1 - w_c) + p01.scale * w_c;
            const s_btm = p10.scale * (1 - w_c) + p11.scale * w_c;
            const finalScale = s_top * (1 - w_r) + s_btm * w_r;

            // æ’å€¼ Depth (ä»…å±•ç¤º)
            const d_top = p00.depth_val * (1 - w_c) + p01.depth_val * w_c;
            const d_btm = p10.depth_val * (1 - w_c) + p11.depth_val * w_c;
            currentDepthVal.value = Math.round(d_top * (1 - w_r) + d_btm * w_r);

            currentScale.value = finalScale;
          };

          return {
            loadFile,
            bgSrc,
            charImgSrc,
            charPos,
            baseWidth,
            isDragging,
            startDrag, // æš´éœ²ç»™ template
            navMesh,
            currentScale,
            currentDepthVal,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
