<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>360 Avatar Scale Debugger</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"
    />
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"
    ></script>

    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        font-family: sans-serif;
        background: #222;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
      }

      /* 1. 360 æ’­æ”¾å™¨å±‚ (åº•å±‚) */
      #panorama {
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      /* 2. Character å±‚ (ä¸­é—´äº¤äº’å±‚) */
      .character-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        pointer-events: none; /* è®©é¼ æ ‡äº‹ä»¶ç©¿é€åˆ°ä¸‹é¢çš„æ’­æ”¾å™¨ï¼Œé™¤éç‚¹ä¸­ character */
      }

      .avatar-container {
        position: absolute;
        transform-origin: bottom center; /* ç¼©æ”¾ä¸­å¿ƒåœ¨è„šåº• */
        cursor: grab;
        pointer-events: auto; /* å…è®¸æ‹–æ‹½ */
        user-select: none;
        border: 2px dashed rgba(255, 255, 0, 0.5); /* è°ƒè¯•è¾…åŠ©æ¡† */
      }
      .avatar-container:active {
        cursor: grabbing;
        border-color: yellow;
      }
      .avatar-img {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }

      /* 3. UI æ§åˆ¶é¢æ¿ (é¡¶å±‚) */
      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 320px;
        background: rgba(0, 0, 0, 0.85);
        color: #eee;
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      }
      .section {
        margin-bottom: 15px;
        border-bottom: 1px solid #444;
        padding-bottom: 10px;
      }
      .row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }
      h3 {
        margin: 0 0 10px 0;
        color: #3498db;
      }
      label {
        font-size: 12px;
        color: #aaa;
        display: block;
        margin-bottom: 2px;
      }
      input[type="file"] {
        font-size: 11px;
        width: 100%;
        margin-bottom: 5px;
      }
      .info-val {
        color: #00ff00;
        font-family: monospace;
        font-weight: bold;
      }
      .base-scale-slider {
        width: 100%;
      }

      /* å‡†æ˜Ÿè¾…åŠ© */
      .crosshair {
        position: absolute;
        top: 0;
        left: 0;
        width: 10px;
        height: 10px;
        background: red;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 20;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="app" @mousemove="onMouseMove" @mouseup="onMouseUp">
      <div id="panorama"></div>

      <div class="character-layer" v-if="charImgSrc">
        <div
          class="avatar-container"
          :style="{ 
                 left: charPos.x + 'px', 
                 top: charPos.y + 'px',
                 width: baseWidth + 'px',
                 transform: `translate(-50%, -100%) scale(${currentScale})` 
             }"
          @mousedown.stop="onMouseDown"
        >
          <img :src="charImgSrc" class="avatar-img" />
        </div>
        <div
          class="crosshair"
          :style="{ left: charPos.x + 'px', top: charPos.y + 'px', display: 'block' }"
        ></div>
      </div>

      <div class="controls">
        <h3>ğŸ—ï¸ Avatar Scene Debugger</h3>

        <div class="section">
          <label>1. èƒŒæ™¯å…¨æ™¯å›¾ (JPG)</label>
          <input
            type="file"
            accept="image/*"
            @change="e => loadFile(e, 'bg')"
          />

          <label>2. åœºæ™¯æ•°æ® (JSON)</label>
          <input
            type="file"
            accept="application/json"
            @change="e => loadFile(e, 'json')"
          />

          <label>3. è§’è‰²å›¾ç‰‡ (PNG)</label>
          <input
            type="file"
            accept="image/*"
            @change="e => loadFile(e, 'char')"
          />
        </div>

        <div class="section" v-if="navMesh">
          <div class="row">
            <span>Current Scale:</span>
            <span class="info-val">{{ currentScale.toFixed(3) }}</span>
          </div>
          <div class="row">
            <span>Grid Depth:</span>
            <span class="info-val">{{ currentDepthVal }}</span>
          </div>
          <div class="row">
            <span>UV Coordinate:</span>
            <span style="font-size: 10px"
              >U:{{ currentUV.u.toFixed(3) }} V:{{ currentUV.v.toFixed(3)
              }}</span
            >
          </div>
        </div>

        <div class="section">
          <label>Avatar åŸºç¡€å¤§å° (px): {{ baseWidth }}</label>
          <input
            type="range"
            v-model.number="baseWidth"
            min="50"
            max="500"
            class="base-scale-slider"
          />
          <small style="color: #666">è°ƒæ•´æ­¤å€¼ä»¥åŒ¹é…è®¾è®¡ç¨¿åŸå§‹å°ºå¯¸</small>
        </div>

        <div style="font-size: 10px; color: #666">
          æ“ä½œï¼šæ‹–æ‹½äººç‰©ç§»åŠ¨ã€‚<br />
          æ³¨æ„ï¼šScale è®¡ç®—åŸºäºè„šåº•çº¢ç‚¹ä½ç½®ã€‚
        </div>
      </div>
    </div>

    <script>
      const { createApp, ref, reactive, onMounted, computed } = Vue;

      createApp({
        setup() {
          // State
          const viewer = ref(null);
          const navMesh = ref(null);

          // Assets
          const bgSrc = ref(null);
          const charImgSrc = ref(null);

          // Character State
          const charPos = reactive({
            x: window.innerWidth / 2,
            y: window.innerHeight * 0.8,
          });
          const isDragging = ref(false);
          const baseWidth = ref(200); // è§’è‰²å›¾ç‰‡çš„åŸºç¡€æ˜¾ç¤ºå®½åº¦

          // Real-time Calculation
          const currentScale = ref(1.0);
          const currentDepthVal = ref(0);
          const currentUV = reactive({ u: 0, v: 0 });

          // Grid Data Cache
          let gridData = null; // { rows, cols, data[r][c] }

          // --- 1. File Loading ---
          const loadFile = (event, type) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
              if (type === "bg") {
                initViewer(e.target.result);
              } else if (type === "char") {
                charImgSrc.value = e.target.result;
              } else if (type === "json") {
                try {
                  const json = JSON.parse(e.target.result);
                  // å…¼å®¹ v2/v3 æ ¼å¼
                  navMesh.value = json.nav_mesh || json;
                  processGridData();
                } catch (err) {
                  alert("JSON æ ¼å¼é”™è¯¯");
                }
              }
            };

            if (type === "json") reader.readAsText(file);
            else reader.readAsDataURL(file);
          };

          // --- 2. Pannellum Viewer ---
          const initViewer = (imageSrc) => {
            if (viewer.value) viewer.value.destroy();

            viewer.value = pannellum.viewer("panorama", {
              type: "equirectangular",
              panorama: imageSrc,
              autoLoad: true,
              compass: false,
              showZoomCtrl: false,
              mouseZoom: false, // ç¦ç”¨æ»šè½®ç¼©æ”¾ï¼Œé¿å…å¹²æ‰°æ‹–æ‹½ä½“éªŒ
              pitch: -20, // åˆå§‹è§†è§’çœ‹åœ°é¢
            });

            // ç›‘å¬è§†è§’å˜åŒ–ï¼Œå› ä¸ºè§†è§’å˜äº†ï¼Œå±å¹•ä¸ŠåŒä¸€ä¸ªç‚¹çš„ Scale ä¹Ÿä¼šå˜
            viewer.value.on("mouseup", updateScaleFromScreenPos);
            viewer.value.on("animate", updateScaleFromScreenPos); // æ—‹è½¬æ—¶æŒç»­æ›´æ–°
          };

          // --- 3. Drag Logic ---
          const onMouseDown = (e) => {
            isDragging.value = true;
          };

          const onMouseMove = (e) => {
            if (isDragging.value) {
              charPos.x = e.clientX;
              charPos.y = e.clientY;
              updateScaleFromScreenPos();
            }
          };

          const onMouseUp = () => {
            isDragging.value = false;
          };

          // --- 4. The Core Algorithm: Screen -> UV -> Grid Interpolation ---

          const processGridData = () => {
            if (!navMesh.value) return;
            const mesh = navMesh.value;
            // å°† flat points æ•°ç»„è½¬æ¢ä¸º 2D çŸ©é˜µæ–¹ä¾¿æŸ¥è¯¢
            // å‡è®¾ points æ˜¯æŒ‰è¡Œä¼˜å…ˆæˆ–åˆ—ä¼˜å…ˆæ’åˆ—çš„ï¼Œæˆ‘ä»¬å»ºç«‹æŸ¥æ‰¾è¡¨
            const grid = Array(mesh.rows)
              .fill(0)
              .map(() => Array(mesh.cols).fill(null));

            mesh.points.forEach((pt) => {
              const c = pt.grid_pos[0];
              const r = pt.grid_pos[1];
              if (r < mesh.rows && c < mesh.cols) {
                grid[r][c] = pt;
              }
            });
            gridData = grid;
            updateScaleFromScreenPos(); // åˆå§‹è®¡ç®—
          };

          const updateScaleFromScreenPos = () => {
            if (!viewer.value || !gridData) return;

            // A. Screen (x,y) -> Spherical (Pitch, Yaw)
            // Pannellum æä¾› mouseEventToCoordsï¼Œæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿä¸€ä¸ª event å¯¹è±¡
            // æˆ–è€…æ›´ç›´æ¥ï¼šæˆ‘ä»¬éœ€è¦åå‘æŠ•å½±ã€‚Pannellum æ²¡æœ‰ç›´æ¥æš´éœ² pixelToCoords
            // ä½† mouseEventToCoords å®é™…ä¸Šæ˜¯ç”¨ clientX/Y è®¡ç®—çš„ã€‚

            // æˆ‘ä»¬æ„é€ ä¸€ä¸ªä¼ªé€ çš„ event å¯¹è±¡ä¼ å…¥
            const mockEvent = {
              clientX: charPos.x,
              clientY: charPos.y,
              target: viewer.value.getContainer(), // éœ€è¦æ˜¯ canvas å®¹å™¨
            };

            // è·å–å¯¹åº”çƒåæ ‡
            const coords = viewer.value.mouseEventToCoords(mockEvent);
            // æ³¨æ„ï¼šå¦‚æœé¼ æ ‡åœ¨ç”»é¢å¤–ï¼ŒPannellum å¯èƒ½è¿”å› undefined
            if (!coords || coords.length < 2) return;

            const pitch = coords[0];
            const yaw = coords[1];

            // B. Spherical -> UV
            // Equirectangular mapping:
            // U = (Yaw + 180) / 360  (0..1)
            // V = (90 - Pitch) / 180 (0..1) -> 0 is Top, 1 is Bottom

            let u = (yaw + 180) / 360.0;
            let v = (90 - pitch) / 180.0;

            // è§„èŒƒåŒ– u, v
            u = u % 1.0;
            if (u < 0) u += 1.0;
            v = Math.max(0, Math.min(1, v));

            currentUV.u = u;
            currentUV.v = v;

            // C. Bilinear Interpolation on Grid
            calculateScaleFromUV(u, v);
          };

          const calculateScaleFromUV = (u, v) => {
            if (!navMesh.value) return;
            const { rows, cols } = navMesh.value;

            // æˆ‘ä»¬çš„ Grid æ˜¯éçº¿æ€§çš„å—ï¼Ÿä¸ï¼Œæˆ‘ä»¬ä¹‹å‰ç”Ÿæˆçš„æ˜¯å‡åŒ€ç½‘æ ¼
            // row_steps = 0.55 -> 0.95
            // col_steps = 0.0 -> 1.0

            // å¿…é¡»ç¡¬ç¼–ç æˆ‘ä»¬åœ¨ Python é‡Œå®šä¹‰çš„èŒƒå›´ï¼Œæˆ–è€…ä» JSON é‡Œè¯»å–ï¼ˆå¦‚æœå­˜äº†çš„è¯ï¼‰
            // å‡è®¾ Python ä»£ç æœªå˜ï¼š
            const V_START = 0.55;
            const V_END = 0.95;
            const U_START = 0.0;
            const U_END = 1.0;

            // å¦‚æœ v è¶…å‡ºç½‘æ ¼èŒƒå›´ï¼ˆæ¯”å¦‚çœ‹å‘å¤©ç©ºï¼‰ï¼Œç»™é»˜è®¤å€¼
            if (v < V_START) {
              currentScale.value = 0.1; // æè¿œå¤„
              return;
            }
            if (v > V_END) {
              currentScale.value = 2.5; // æè¿‘å¤„ (æˆ–å–ç½‘æ ¼æœ€å¤§å€¼)
              return;
            }

            // æ‰¾åˆ°å¯¹åº”çš„ Grid ç´¢å¼• (float)
            // U æ˜¯ 0-360 å¾ªç¯çš„ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†è¾¹ç•Œ
            const u_ratio = (u - U_START) / (U_END - U_START); // 0..1
            const v_ratio = (v - V_START) / (V_END - V_START); // 0..1

            let c_float = u_ratio * cols;
            let r_float = v_ratio * (rows - 1); // rows ä¸ªç‚¹ï¼Œæœ‰ rows-1 ä¸ªé—´éš”

            // è·å– 4 ä¸ªä¸´è¿‘ç‚¹ç´¢å¼•
            let c0 = Math.floor(c_float) % cols;
            let c1 = (c0 + 1) % cols; // å¾ªç¯è¿æ¥
            let r0 = Math.floor(r_float);
            let r1 = Math.min(r0 + 1, rows - 1);

            // æƒé‡
            let w_c = c_float - Math.floor(c_float);
            let w_r = r_float - Math.floor(r_float);

            // æŸ¥è¡¨
            const p00 = gridData[r0][c0];
            const p01 = gridData[r0][c1];
            const p10 = gridData[r1][c0];
            const p11 = gridData[r1][c1];

            if (!p00 || !p01 || !p10 || !p11) return;

            // åŒçº¿æ€§æ’å€¼ Scale
            const s0 = p00.scale * (1 - w_c) + p01.scale * w_c;
            const s1 = p10.scale * (1 - w_c) + p11.scale * w_c;
            const finalScale = s0 * (1 - w_r) + s1 * w_r;

            // æ’å€¼ Depth (ç”¨äºè°ƒè¯•)
            const d0 = p00.depth_val * (1 - w_c) + p01.depth_val * w_c;
            const d1 = p10.depth_val * (1 - w_c) + p11.depth_val * w_c;
            currentDepthVal.value = Math.round(d0 * (1 - w_r) + d1 * w_r);

            currentScale.value = finalScale;
          };

          return {
            loadFile,
            bgSrc,
            charImgSrc,
            charPos,
            onMouseDown,
            onMouseMove,
            onMouseUp,
            baseWidth,
            navMesh,
            currentScale,
            currentDepthVal,
            currentUV,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
